document.addEventListener('DOMContentLoaded', function () {
    const sidebarMenu = document.querySelector('#sidebar-menu .navbar-nav');
    if (!sidebarMenu) return; // Guard if not found

    // Grab all top-level sidebar items (li.nav-item).
    const originalItems = Array.from(sidebarMenu.querySelectorAll('.nav-item'));

    // A helper to compute a simple "match score" (longer matches => higher score).
    // For real fuzzy searching, consider external libraries or more complex logic.
    function getMatchScore(text, query) {
        // Example: simple substring check
        let score = 0;
        const index = text.toLowerCase().indexOf(query.toLowerCase());
        if (index !== -1) {
            // Closer to start => slightly higher score, plus length factor
            score = 100 - index * 5 + query.length;
        }
        return score;
    }

    // Re-render the sorted items in the sidebar
    function renderSidebarItems(items) {
        // Clear existing list
        sidebarMenu.innerHTML = '';
        // Append the sorted items
        items.forEach(item => sidebarMenu.appendChild(item));
    }

    // Listen to changes in the search input
    const searchInput = document.getElementById('topbarSearchInput');
    if (!searchInput) return;

    searchInput.addEventListener('input', function () {
        const query = this.value.trim();
        if (!query) {
            // If search is empty, revert to the original ordering
            renderSidebarItems(originalItems);
            return;
        }

        // Build a new array that includes each item + its match score
        const scoredItems = originalItems.map(item => {
            // For each nav-link, we can check .nav-link-title text
            const linkTitleEl = item.querySelector('.nav-link-title');
            const linkText = linkTitleEl ? linkTitleEl.textContent : '';
            const score = getMatchScore(linkText, query);
            return { item, score };
        });

        // Sort them by descending score
        scoredItems.sort((a, b) => b.score - a.score);

        // If you prefer to HIDE items that do not match, do something like:
        // scoredItems = scoredItems.filter(obj => obj.score > 0);

        // Extract items in new order
        const sortedItems = scoredItems.map(obj => obj.item);

        // Re-render the sidebar with sorted items
        renderSidebarItems(sortedItems);
    });
});
/*
 * Mojar CMS 1.0 - Data Table Enhanced
 *
 */

$(document).ready(function () {
    // console.log('data-table-enhanced.js 2.0');
});


/*
 * Mojar CMS 1.0 - Main Dashboard Layout
 *
 */

document.addEventListener("DOMContentLoaded", function () {
    const themeSwitcher = {
        init() {
            this.themeButtons = document.querySelectorAll(
                "[data-bs-theme-value]"
            );
            this.themeElements = document.querySelectorAll("[data-bs-theme]");
            this.defaultTheme = "light";
            this.currentTheme =
                localStorage.getItem("theme") || this.defaultTheme;

            // Set initial theme
            this.setTheme(this.currentTheme);
            this.bindEvents();

            // Watch system theme changes
            this.watchSystemTheme();
        },

        setTheme(theme) {
            // Update all elements with data-bs-theme attribute
            this.themeElements.forEach((element) => {
                element.setAttribute("data-bs-theme", theme);
            });

            localStorage.setItem("theme", theme);

            this.themeButtons.forEach((button) => {
                button.classList.toggle(
                    "active",
                    button.getAttribute("data-bs-theme-value") === theme
                );
            });

            // Animate theme change
            document.body.style.transition = "background-color 0.3s ease";
        },

        watchSystemTheme() {
            if (window.matchMedia) {
                const mediaQuery = window.matchMedia(
                    "(prefers-color-scheme: dark)"
                );
                mediaQuery.addEventListener("change", (e) => {
                    if (!localStorage.getItem("theme")) {
                        this.setTheme(e.matches ? "dark" : "light");
                    }
                });
            }
        },

        bindEvents() {
            this.themeButtons.forEach((button) => {
                button.addEventListener("click", () => {
                    const theme = button.getAttribute("data-bs-theme-value");
                    this.setTheme(theme);

                    // Add ripple effect
                    const ripple = document.createElement("div");
                    ripple.classList.add("ripple");
                    button.appendChild(ripple);
                    setTimeout(() => ripple.remove(), 1000);
                });
            });
        },
    };

    // Enhanced Sidebar
    const sidebarManager = {
        init() {
            this.sidebar = document.querySelector(".mojar-sidebar");
            this.toggle = document.querySelector(".navbar-toggler");
            this.overlay = document.createElement("div");
            this.overlay.classList.add("sidebar-overlay");

            this.bindEvents();
            this.setupResizeHandler();
        },

        bindEvents() {
            if (this.toggle && this.sidebar) {
                this.toggle.addEventListener("click", () =>
                    this.toggleSidebar()
                );
            }

            // Close sidebar when clicking overlay
            this.overlay.addEventListener("click", () => this.closeSidebar());

            // Handle escape key
            document.addEventListener("keydown", (e) => {
                if (e.key === "Escape") this.closeSidebar();
            });
        },

        toggleSidebar() {
            this.sidebar.classList.toggle("show");
            document.body.classList.toggle("sidebar-open");

            if (this.sidebar.classList.contains("show")) {
                document.body.appendChild(this.overlay);
                setTimeout(() => this.overlay.classList.add("show"), 50);
            } else {
                this.closeSidebar();
            }
        },

        closeSidebar() {
            this.sidebar.classList.remove("show");
            document.body.classList.remove("sidebar-open");
            this.overlay.classList.remove("show");
            setTimeout(() => this.overlay.remove(), 300);
        },

        setupResizeHandler() {
            let timeout;
            window.addEventListener("resize", () => {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    if (window.innerWidth >= 992) {
                        this.closeSidebar();
                    }
                }, 250);
            });
        },
    };

    // Enhanced Dropdowns
    const dropdownManager = {
        init() {
            this.dropdowns = document.querySelectorAll(".dropdown");
            this.bindEvents();
        },

        bindEvents() {
            this.dropdowns.forEach((dropdown) => {
                const toggle = dropdown.querySelector(".dropdown-toggle");
                const menu = dropdown.querySelector(".dropdown-menu");

                if (toggle && menu) {
                    toggle.addEventListener("click", (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        this.toggleDropdown(dropdown);
                    });
                }
            });

            // Close dropdowns when clicking outside
            document.addEventListener("click", (e) => {
                if (!e.target.closest(".dropdown")) {
                    this.closeAllDropdowns();
                }
            });
        },

        toggleDropdown(dropdown) {
            const isOpen = dropdown.classList.contains("show");

            // Close other dropdowns
            this.closeAllDropdowns();

            if (!isOpen) {
                dropdown.classList.add("show");
                dropdown.querySelector(".dropdown-menu").classList.add("show");
            }
        },

        closeAllDropdowns() {
            this.dropdowns.forEach((dropdown) => {
                dropdown.classList.remove("show");
                const menu = dropdown.querySelector(".dropdown-menu");
                if (menu) menu.classList.remove("show");
            });
        },
    };

    // Initialize all managers
    themeSwitcher.init();
    // sidebarManager.init();
    // dropdownManager.init();
});

(function () {
    // Create a global "CustomToast" object
    window.CustomToast = {
        /**
         * Show a new toast
         * @param {Object} options
         *   options.title - string (optional)
         *   options.message - string (required)
         *   options.type - "success", "error", "warning", "info", etc. (default "info")
         *   options.duration - time in ms to auto-hide (default 3000)
         *   options.onClose - callback when the toast is closed
         */
        show: function (options) {
            const {
                title = "",
                message = "",
                type = "info",
                duration = 3000,
                onClose = null,
            } = options || {};

            // Ensure container exists
            let container = document.querySelector(".custom-toast-container");
            if (!container) {
                container = document.createElement("div");
                container.className = "custom-toast-container";
                document.body.appendChild(container);
            }

            // Build the toast element
            const toastEl = document.createElement("div");
            toastEl.className = `custom-toast border-${mapTypeToBorder(type)}`;

            // Fill the toast content
            toastEl.innerHTML = `
          <div class="custom-toast-header">
            <span class="custom-toast-title">${title || ""}</span>
            <button type="button" class="custom-toast-close" aria-label="Close">&times;</button>
          </div>
          <div class="custom-toast-message">${message}</div>
        `;

            // Append it to the container
            container.appendChild(toastEl);

            // Use slight delay to trigger animation
            setTimeout(() => {
                toastEl.classList.add("show-toast");
            }, 10);

            // Handle manual close
            const closeBtn = toastEl.querySelector(".custom-toast-close");
            closeBtn.addEventListener("click", function () {
                removeToast(toastEl, onClose);
            });

            // Auto-hide after "duration" ms (if duration > 0)
            if (duration && duration > 0) {
                setTimeout(() => {
                    removeToast(toastEl, onClose);
                }, duration);
            }
        },
    };

    // Helper to remove the toast
    function removeToast(toastEl, onClose) {
        toastEl.classList.remove("show-toast");
        // Wait for CSS transition
        setTimeout(() => {
            toastEl.remove();
            if (typeof onClose === "function") {
                onClose();
            }
        }, 300);
    }

    // Helper to map "type" -> correct color classes
    function mapTypeToBorder(type) {
        switch (type) {
            case "success":
                return "success";
            case "error":
                return "danger";
            case "warning":
                return "warning";
            case "info":
                return "info";
            default:
                return "info";
        }
    }
})();


/**
 * Usage:
 CustomToast.show({
  title: "Success!",
  message: "Your plugin was activated successfully.",
  type: "success", // success | error | warning | info
  duration: 4000,  // 4s
  onClose: function() {
    console.log("Toast closed!");
  }
    });
* for error
    CustomToast.show({
  title: "Oops!",
  message: "Something went wrong while deleting the plugin.",
  type: "error",
  duration: 0 // if you want the toast to stay until user closes
});
 */